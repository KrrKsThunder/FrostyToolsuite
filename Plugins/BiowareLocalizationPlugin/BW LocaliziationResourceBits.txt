Part:	Type and what					Byte position after this

MetaData (16 bytes, located in Frosty at Resource.resMeta, not part of the byte count )
{
    uint dataOffset
    3x  byte value 0x0
}
Header
{
    uint magic = 0xd78b40eb			(pos 4)
    uint ???						(pos 8)			// doesn't seem to affect anything
    uint dataOffset					(pos 12)		// not actually used, instead the one from the metadata is the base for the game
    3x uint ???						(pos 24)		// doens't seem to affect anything

    uint nodeCount					(pos 28)
    // the number of nodes in the huffman tree, this is an even integer! The rootNode as would-be last node in the node list is *not* actually part of the list!

    uint nodeOffset					(pos 32)

    uint stringsCount				(pos 36)
    uint stringsOffset				(pos 40)

    // Until the nodeOffset is reached
    // If they exist, then at least 2 times.
    // - a last entry might contain zeros or the same as the last position and is not used
    N times 8ByteBlockCountAndOffset
    {
        uint counts
        uint offset
    }
}

// Position = nodeOffset -> pos most likely either 56 or 64
HuffmanCoding
{
    nodeCount x uint value == bitFlip char
}
    (size = 4 per node)
	
// Position = stringsOffset
StringData
{
    stringsCount x
    {
        uint stringId
        int stringIndex / positionOffset
    }
        (size = 8 per string)
}
	
// Position = 8ByteBlockCountAndOffset[0].offset
// The next data blocks appears the same N times as their 8ByteBlockCountAndOffset counterpart in the header
//
// - The first block contains the text id of crafted weapons or parts as number, but shifted to the range of 0xA0000000. Example: ID 0x43FAA for "Haft" becomes 0xA0043FAA.
//   After this ID, the second number links the item to the variation of adjective to use ( e.g., declination or conjugation or whaever ), these take the form of 0 ( for english )
//   The variant numbers are take the form of 0 (no variations, english), 0x101,0x102,0x201,0x202,0x301,0x302 also with 0x10000 variants like 10101,10202 etc.
//   This is likely linked to the LanguageDefinition... LocalizedLanguage Assets found under Systems/Localization in DAI and Systems/Bioware/Localization in MEA
//
// - The second block maps these variants to the block offset to search the ID in. This block offset is the number of count + offset tubles, including those for nodes and strings.
//   That means that the lowest number is 4, counting update from there. For english, this means this contains a single tuple: 0 - 4, while for french it goes up to 0x102020 - xB
//
// - Everything past the second of these blocks contains the bit offsets of the text pieces used for crafted item names in DA:I. The first of this adjective id including blocks has the numbering 4 in the previous block.
N times 8ByteBlockData
{
    // Position = 8ByteBlockCountAndOffset[index].offset
    byte[].Length = 8ByteBlockCountAndOffset[index].counts * 8
}

// Position = dataOffset
Strings
{
    stringsCount + DAI adjectives as Huffman encoded chars. Might overlapp in game files!
}
    // stringIndex / positionOffset = bit offset from dataOffset == textBefore bitOffset + textBefore bitlentgh
    // last symbol (only symbol of empty string) is huffman node with letter 0x00! I.e., _value_ = 0xFF
	
Remaining positions to full byte filled with 0s